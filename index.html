<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ginger Syrup - 141 | All for one</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="s-page-1">
      <div class="s-section-1">
        <div class="s-section"></div>
      </div>
    </div>

    <header class="main-header">
      <nav class="main-nav">
        <a href="#" class="menu-button">
          <div class="menu-icon-svg">
            <svg class="book-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" style="enable-background:new 0 0 128 128" xml:space="preserve">
              <path d="M110.6 38.3H106v-3.5c0-1-.8-1.7-1.7-1.8H70.8c-2.7 0-5.2 1.2-6.8 3.3-1.6-2.1-4.1-3.3-6.8-3.3H23.7c-1 0-1.7.8-1.7 1.8v3.5h-4.6c-1 0-1.8.8-1.8 1.8v57c0 1 .8 1.7 1.8 1.8h93.1c1 0 1.7-.8 1.8-1.8V40c0-.9-.8-1.7-1.7-1.7zm-39.8-1.8h31.7v51.9H70.8c-2.9 0-4.6 1.4-5 1.6V41.6c0-.4 0-.7-.1-1.1.5-2.2 2.6-4 5.1-4zm-45.3 0h31.7c2.6 0 4.7 1.9 5 4.1 0 .4-.1.7-.1 1.1V90c-.3-.1-2.1-1.6-5-1.6H25.5V36.5zm-6.3 5.3H22v48.3c0 1 .8 1.8 1.8 1.8h33.5c2 0 3.9 1.1 4.8 3.4H19.2V41.8zm89.6 53.5H66c.8-2.2 2.8-3.4 4.8-3.4h33.5c1 0 1.8-.8 1.8-1.8V41.8h2.8l-.1 53.5z"/>
              <path d="M32.7 50h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H32.7c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8zM32.7 59.3h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H32.7c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8zM32.7 68.7h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H32.7c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8zM32.7 78h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H32.7c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8zM72.8 50h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H72.8c-1 0-1.8.8-1.8 1.8s.9 1.8 1.8 1.8zM72.8 59.3h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H72.8c-1 0-1.8.8-1.8 1.8s.9 1.8 1.8 1.8zM72.8 68.7h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H72.8c-1 0-1.8.8-1.8 1.8s.9 1.8 1.8 1.8zM72.8 78h22.5c1 0 1.8-.8 1.8-1.8s-.8-1.8-1.8-1.8H72.8c-1 0-1.8.8-1.8 1.8s.9 1.8 1.8 1.8z"/>
          </svg>
            <span class="icon-label">MENU</span>
          </div>
        </a>
        <div class="nav-menu-panel">
          <ul>
            <li><a href="#">Our Products</a></li>
            <li><a href="#">Merchandise</a></li>
            <li><a href="#">Wholesale Sales</a></li>
            <li><a href="#">Notice</a></li>
            <li><a href="#">Contact</a></li>  
          </ul>
          <div class="social-icons">
            <a href="#"> <i class="fab fa-instagram"></i> </a>
            <a href="#"> <i class="fab fa-twitter"></i> </a>
          </div>
        </div>
      </nav>
    </header>

    <aside class="sidebar-left">
      <p class="vertical-text">Our Products</p>
    </aside>

    <main class="main-content-wrapper">
      <section class="left-panel">
        <h1>We are a ginger enthusiast<br/>based in Rome.</h1>
        <p class="description-line1">
          To the north, green rolling hills stretch; to the west
          the coastline overlooks the sparkling Mediterranean.
        </p>
        <p class="description-line2">
          Embracing the vibrancy of ancient Rome
          and the blessings of nature. From a single cup of ginger syrup, 
          we pursue comfortable living and weave it  <br/>into the future.
        </p>
        
      
        <div class="ginger-icon-container">
          <svg class="ginger-icon" enable-background="new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
              <g id="_x32_0_Ginger">
                  <g>
                      <path d="m438.888 163.01c-31.758-25.014-81.512-12.731-95.107 29.43-12.137-34.169-11.312-53.266-9.89-74.626 1.633-24.407 2.644-49.237-12.995-68.563-22.749-28.157-68.91-24.475-85.222 11.099-8.487-12.525-19.79-24.763-32.129-34.647-43.066-34.349-96.407-21.021-119.816 23.409-12.649 24.05-13.59 53.279-4.962 79.698-.51 2.265.374 3.975 1.882 5.137 18.494 49.031 62.182 79.439 108.823 103.321 14.403 6.139 16.537 10.51 16.781 12.062 1.441 9.713-24.395 8-33.45 6.086-27.022-5.713-57.82-23.075-88.82-14.479-17.345 4.818-30.787 18.418-33.44 33.832-2.297 13.252 2.978 27.85 14.108 39.038 6.068 6.139 13.31 10.784 20.633 14.514-20.801 8.54-37.913 29.032-41.709 51.995-4.503 27.601 11.226 57.314 36.586 69.112 29.314 13.694 62.108 3.883 93.191-7.326 18.178-6.586 35.992-12.423 52.84-13.808 1.954 1.099 3.676.894 5.407-.285 9.462-.213 18.595 1.118 27.27 4.767 17.578 7.407 30.137 23.036 43.62 37.394 7.181 7.694 15.902 16.438 26.132 22.951 24.999 15.842 59.984 17.264 86.955 1.265 27.042-16.016 52.219-43.775 41.785-73.645-12.651-36.197-3.748-74.587 2.389-108.168.696-3.464 10.925-54.845 9.258-62.778 1.349-31.632-5.284-67.175-30.12-86.785zm-28.618 322.421v.003c-28.726 17.035-65.427 13.636-96.732-18.772 11.383-11.107 25.855-20.786 39.05-29.099 26.628-16.797 57.612-34.651 89.623-35.039 1.142 7.528 3.335 15.962 5.321 21.647 8.429 24.135-15.156 48.165-37.262 61.26zm39.275-174.906c-4.506 24.088-10.739 52.069-8.425 81.658-33.838.748-65.927 18.815-94.082 36.575-15.116 9.52-28.159 18.361-40.55 30.41-12.993-14.122-25.798-28.491-43.579-35.985-7.915-3.33-16.027-4.966-24.29-5.454 11.703-21.436 15.101-47.24 8.998-70.956-.717-2.785-3.588-4.449-6.337-3.74-2.785.717-4.462 3.552-3.746 6.337 5.95 23.105 1.694 48.373-11.176 68.427-18.298 1.34-37.262 7.528-56.543 14.516-2.479.894-4.971 1.771-7.468 2.635 3.686-23.94-.318-49.246-11.463-70.697-1.332-2.551-4.467-3.547-7.018-2.218-2.551 1.324-3.542 4.467-2.221 7.016 10.972 21.106 14.301 46.304 9.42 69.597-23.1 7.1-46.282 10.802-66.508 1.347-21.284-9.902-34.487-34.838-30.711-57.989 3.959-23.944 24.867-44.695 47.599-47.243 5.352-.597 6.365-7.992 1.362-9.999-10.408-4.183-22.204-9.623-30.767-18.283-8.635-8.68-12.939-20.148-11.242-29.936 2.297-13.323 14.697-22.445 25.965-25.576 27.392-7.59 56.143 8.761 83.89 14.634 19.975 4.063 48.89 2.404 45.891-17.836-1.545-9.867-13.859-16.181-22.656-19.914-7.043-3.613-14.852-7.763-22.953-12.519 12.897-7.917 22.795-20.842 26.602-35.482.722-2.782-.945-5.623-3.725-6.348-2.78-.717-5.626.94-6.348 3.725-3.601 13.836-13.786 25.822-26.758 31.811-28.876-18.426-54.613-41.975-68.338-73.788 25.216-.568 50.455-11.603 67.546-30.09 1.952-2.109 1.819-5.402-.29-7.354-2.109-1.949-5.397-1.827-7.354.29-16.061 17.366-40.177 27.288-63.86 26.69-7.83-24.637-6.202-50.422 4.526-70.826 19.79-37.56 65.22-51.156 104.107-20.125 14.321 11.468 27.611 26.935 35.554 41.376 2.339 4.262 8.774 3.246 9.676-1.555 6.219-33.385 49.187-44.265 70.53-17.861 6.673 8.251 10.457 19.673 11.327 33.928-11.128 1.512-22.664-.879-32.256-6.81-2.444-1.509-5.651-.757-7.166 1.69-1.509 2.444-.757 5.651 1.687 7.163 10.985 6.794 24.432 9.976 37.945 8.429-.099 5.543-.448 11.125-.835 16.926-1.985 29.768-1.052 53.566 17.818 97.48 2.263 5.278 10.19 3.484 9.981-2.239-1.494-42.658 48.065-67.227 81.136-41.18 21.532 17 27.143 48.909 26.209 76.507-25.469 13.325-56.505 16.005-83.789 6.911-2.754-.92-5.672.567-6.581 3.291-.91 2.727.564 5.674 3.288 6.584 27.24 9.08 58.688 7.801 86.313-4.753-1.559 16.97-4.969 34.033-8.335 50.803z"/>
                  </g>
              </g>
          </svg>
          </div>
       
        
      </section>
     
      <section class="right-panel">
        <div class="carousel-container">
          <div class="carousel-track">
            <img
              src="ChatGPT Image 2025年7月24日 06_16_09.PNG"
              alt="海の風景1"
              class="carousel-image active"
            />
            <img
              src="ChatGPT Image 2025年7月24日 06_16_09.PNG"
              alt="海の風景2"
              class="carousel-image"
            />
            <img
              src="ChatGPT Image 2025年7月24日 06_16_09.PNG"
              alt="海の風景3"
              class="carousel-image"
            />
          </div>
          </div>
        
       
       
      
        <div class="carousel-dots">
          <span class="dot active"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
      
        <div class="brand-info">
         <div class="category-info">
          <p class="category-title">141 | All for one</P>
          <p class="category">Ginger Syrup<br/>Craft Made</P>
          </div>

        

       
        </div>
      </section>
    </main>
    <section class="new-section" id="our-story-section">
      <div class="new-section-content">
        <h2 class="fade-in-child">Our Story & Philosophy</h2>
        <div class="new-section-columns">
          <div class="column-left">
            <img
              src="images/ChatGPT Image 2025年7月24日 06_16_09.PNG"
              alt="Our Story Image"
              class="new-section-image new-section-common-image fade-in-child"
              data-parallax-speed="0.5"
            />
            <div class="column-left-left">
              <img
                src="images/ChatGPT Image 2025年7月24日 06_16_09.PNG"
                alt="Our Story Image"
                class="new-section-image1 new-section-common-image fade-in-child"
                data-parallax-speed="0.3"
              />
            </div>
          </div>
          <div class="column-right">
            <p class="fade-in-child">141 Ginger Syrup was created with a deep respect for health.
              It seamlessly blends into your daily life, becoming a natural part of your routine.</p>
            <p class="fade-in-child">For those who prioritize their health and cherish rich, fulfilling moments,
              this syrup adds color, calm, and a gentle clarity to your lifestyle.</p>
            <p class="fade-in-child">We’ve crafted a special drop that adds 
              color to your everyday life.</p>
            <p class="fade-in-child">Non-alcoholic, yet deeply special.
              A guilt-free habit that nourishes you from within.</p>
          </div>
        </div>
      </div>
    </section>
          
            </p>
            
          </div>
        </div>
      </div>
    </section>
    <section class="new-section-sentence" id="ginger-sentence-section">
      <div class="new-section-content-sentence">
        <h2 class="section-title fade-in-child">The Ginger Syrup Has So Much More to Offer.</h2>
        <div class="new-section-columns-sentence">
          <div class="column-left-text-sentence">
            <p class="fade-in-child">
              141 Ginger Syrup gently enhances the everyday, bringing a sense of small richness to your routine moments.
            </p>
            <p class="fade-in-child">
              - Add a spoonful to warm water in the morning to gently awaken your body from the inside out.<br />
            </p>
            <p class="fade-in-child">
              - Mix with sparkling water for a refreshing, non-alcoholic ginger soda.
            </p>
          </div>
          <div class="column-right-text-sentence">
            <p class="fade-in-child">
              The possibilities are endless, depending on your mood or moment. 141 Ginger Syrup is a versatile syrup that fits naturally into your lifestyle —
              never just for one use.
            </p>
            <p class="fade-in-child">
              ▸ Perfect as a thoughtful gift. Beautiful to look at, gentle on the body, and full of care — a small bottle with a heartfelt touch.
            </p>
          </div>
        </div>
      </div>
    </section>
    

    <section class="office-section">
      <div class="office-content">
        <img
          src="IMG_9961.png"
          alt="Office Interior"
          class="office-main-image"
        />
      </div>
    </section>


    <main class="company-profile-wrapper" id="company-profile-section">
      <section class="company-profile-section">
        <h1 class="company-profile-title fade-in-child">Company Profile</h1>
        <div class="company-info-grid">
          <div class="info-row fade-in-child">
            <span class="info-label">Brand Name</span>
            <span class="info-value">141 | All for one</span>
          </div>
          <div class="info-row fade-in-child">
            <span class="info-label">Operated by</span>
            <span class="info-value">RUT INC.</span>
          </div>
          <div class="info-row fade-in-child">
            <span class="info-label">Representative</span>
            <span class="info-value">Kaisei Okubo</span>
          </div>
          <div class="info-row fade-in-child">
            <span class="info-label">Established</span>
            <span class="info-value">2025年9月</span>
          </div>
          <div class="info-row fade-in-child">
            <span class="info-label">Adress</span>
            <span class="info-value">Pastificio Cerere, Via degli Ausoni 3</span>
          </div>
          
      </section>
    </main>
    

    <div class="contact-section">
      <div class="contact-content-wrapper">
        <div class="contact-text-area">
          <h2 class="contact-heading fade-in-child">Feel free to reach out about our ginger syrup.</h2>
          <div class="contact-mark">
            <span class="mark-text">CONTACT</span>
          </div>
          <p class="contact-description fade-in-child">
            Whether you have a question, want to explore wholesale opportunities, 
            or are simply curious.   </p>
            <p class="contact-description fade-in-child">  
            We’re happy to hear from you.
            Please don’t hesitate to get in touch using the contact form.
          </p>
        </div>
    
        <div class="contact-image-group">
          <img
            src="Image 2025年7月24日 06_16_09.PNG"
            alt="メイン画像"
            class="contact-main-img contact-parallax-img-1 fade-in-child" data-parallax-speed="0.5"
          />
          <div class="contact-sub-image-wrapper">
            <img
              src="ChatGPT Image 2025年7月24日 06_16_09.PNG"
              alt="mitone design."
              class="contact-sub-img-positioned contact-parallax-img-2 fade-in-child" data-parallax-speed="0.3"
            />
          </div>
        </div>
      </div>
    </div>
    
        <footer class="footer-section">
          <div class="footer-background">
              </div>
          <div class="footer-content">
              <div class="footer-nav">
             <a href="#">Our Products</a>
             <a href="#">Merchandise</a>
             <a href="#">Wholesale Sales</a>
             <a href="#">Notice</a>
             <a href="#">Contact</a>
              </div>
  
              <div class="footer-right">
                  <div class="footer-brand">
                      <p class="brand-name">141 | All for one</p>
                      <p class="brand-tagline">Ginger Syrup<br>Craft Made</p>
                  </div>
                  <div class="footer-social">
                      <a href="#" aria-label="Instagram"><i class="fab fa-instagram"></i></a>
                      <a href="#" aria-label="Twitter"><i class="fab fa-twitter"></i></a>
                  </div>
              </div>
  
              <div class="footer-info">
                  <p> Pastificio Cerere, Via degli Ausoni 3</p>
                  <p>&copy;141 | One for all. by RUT Inc.</p>
              </div>
          </div>
      </footer>
  
     

      <div id="loading-overlay">
        <span class="loader">Ginger Syrup</span>
       
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>

    <script>
      
      window.onload = function () {
        if (window.VANTA) {
          // VANTA オブジェクトが存在するか確認
          VANTA.FOG({
            // el: "#your-element-selector", // ここをVanta.jsを適用したいHTML要素のセレクタに置き換える
            el: ".s-page-1 .s-section-1 .s-section", // 以前の会話で指定したセレクタ

            mouseControls: true,
  touchControls: true,
  gyroControls: false,
  minHeight: 200.00,
  minWidth: 200.00,
  highlightColor: 0xe8a130,
  midtoneColor: 0xffffff,
  lowlightColor: 0xffffff,
  blurFactor: 0.70,
  speed: 5.00,
  zoom: 2.40
          });
        }
      };
  

</script>
    


    <script src="script.js"></script>

    <script>
      // カルーセル機能 (この下のコードは以前提供したスクリプト.jsの内容をそのまま含めてください)
      document.addEventListener("DOMContentLoaded", () => {
        const images = document.querySelectorAll(".carousel-image");
        const dots = document.querySelectorAll(".dot");
        let currentImageIndex = 0;
        const animationDuration = 5000; // CSSのアニメーション時間 (5秒 = 5000ミリ秒) と一致させる

        let slideInterval; // setIntervalのIDを保持する変数

        // 現在の画像をアクティブにして表示し、ドットを更新する関数
        function showSlide(index) {
          // 全ての画像から 'active' クラスを削除し、指定された画像に 'active' を追加
          images.forEach((img, i) => {
            if (i === index) {
              img.classList.add("active");
            } else {
              img.classList.remove("active");
            }
          });

          // 全てのドットから 'active' クラスを削除し、指定されたドットに 'active' を追加
          dots.forEach((dot, i) => {
            if (i === index) {
              dot.classList.add("active");
            } else {
              dot.classList.remove("active");
            }
          });

          // 現在のアクティブドットのアニメーションをリセットして再開
          resetDotAnimation();
        }

        // ドットのアニメーションをリセットして再開する関数
        function resetDotAnimation() {
          const activeDot = document.querySelector(".dot.active");
          if (activeDot) {
            // 現在のアクティブドットのanimationendリスナーを削除 (次のアニメーション開始時に再設定するため)
            activeDot.removeEventListener("animationend", handleAnimationEnd);

            // アニメーションをリセットするために、activeクラスを一度削除
            activeDot.classList.remove("active");

            // DOMの再描画を強制し、アニメーションのリセットを確実にする
            // これがないと、すぐにactiveを追加してもアニメーションがリセットされない場合がある
            void activeDot.offsetWidth;

            // activeクラスを再追加してアニメーションを最初から開始
            activeDot.classList.add("active");

            // 新しいアニメーション終了時に次のスライドをトリガーするリスナーを再設定
            activeDot.addEventListener("animationend", handleAnimationEnd, {
              once: true,
            });
          }
        }

        // 次の画像に切り替える関数
        function nextSlide() {
          currentImageIndex++;
          if (currentImageIndex >= images.length) {
            currentImageIndex = 0; // 最後の画像に到達したら最初に戻る
          }
          showSlide(currentImageIndex);
        }

        // ドットがクリックされたときのイベントリスナーを設定
        dots.forEach((dot, index) => {
          dot.addEventListener("click", () => {
            // 現在の自動切り替えインターバルをクリア
            clearInterval(slideInterval);

            currentImageIndex = index;
            showSlide(currentImageIndex);

            // クリック後、再度自動切り替えを開始
            startAutoSlide();
          });
        });

        // 自動スライドを開始する関数
        function startAutoSlide() {
          // 既存のインターバルがあればクリア
          clearInterval(slideInterval);

          // CSSアニメーションの終了を検知して次のスライドへ
          // activeなドットが切り替わるたびに、animationendリスナーを再設定
          const activeDot = document.querySelector(".dot.active");
          if (activeDot) {
            // 以前のリスナーを削除する（重複防止）
            activeDot.removeEventListener("animationend", handleAnimationEnd);
            // 新しいリスナーを追加
            activeDot.addEventListener("animationend", handleAnimationEnd, {
              once: true,
            });
          }

          // ここではCSSアニメーションのanimationendイベントでスライドを制御するため、
          // setIntervalによる自動スライドは不要ですが、念のためコメントアウトせずに残します。
          // もしanimationendがうまく機能しない場合のフォールバックとして利用できます。
          // slideInterval = setInterval(nextSlide, animationDuration);
        }

        // アニメーション終了時のハンドラー
        function handleAnimationEnd() {
          // このイベントは animationend によって呼び出される
          nextSlide();
        }

        // ページ読み込み時に最初のスライドを表示し、自動切り替えを開始
        showSlide(currentImageIndex); // 初期表示
        startAutoSlide(); // 自動スライド開始
      });

      // ====================================
      // ナビゲーションメニューの開閉機能の追加
      // ====================================
      document.addEventListener("DOMContentLoaded", () => {
        const menuButton = document.querySelector(".menu-button");
        const navMenuPanel = document.querySelector(".nav-menu-panel");

        if (menuButton && navMenuPanel) {
          // マウスカーソルがボタンに乗った時
          menuButton.addEventListener("mouseenter", () => {
            navMenuPanel.classList.add("is-open");
          });

          // マウスカーソルがメニューパネルから離れた時
          navMenuPanel.addEventListener("mouseleave", () => {
            navMenuPanel.classList.remove("is-open");
          });

          // オプション：メニューボタンから離れてもメニューパネルに残っていれば開いたままにする
          // これがないと、menuButtonからマウスが離れた瞬間にメニューが閉じてしまう
          // menuButtonの親要素である.main-nav全体でホバーを検知するのが良い
          const mainNav = document.querySelector(".main-nav");
          if (mainNav) {
            mainNav.addEventListener("mouseleave", (event) => {
              // マウスが.main-navから完全に離れた場合にのみ閉じる
              // relatedTargetがnullの場合（ブラウザウィンドウ外に出た場合など）も考慮
              if (
                !event.relatedTarget ||
                !mainNav.contains(event.relatedTarget)
              ) {
                navMenuPanel.classList.remove("is-open");
              }
            });
            // mainNavに対するmouseenterは不要だが、
            // menuButtonのmouseenterでis-openを追加するロジックは残す
          }
        }

        // ====================================
        // カルーセル機能 (変更なし)
        // ====================================
        const newSectionImages = document.querySelectorAll(
          ".new-section-columns .new-section-common-image"
        );

        if (newSectionImages.length > 0) {
          window.addEventListener("scroll", () => {
            const viewportHeight = window.innerHeight;

            newSectionImages.forEach((image) => {
              const rect = image.getBoundingClientRect(); // ビューポートに対する要素の位置

              // 画像がビューポート内にあるかどうかを判断
              const isInViewport = rect.top < viewportHeight && rect.bottom > 0;

              if (isInViewport) {
                // --- 共通のスクロール進行度計算 ---
                // 画像の中心がビューポートのどこにあるかを計算 (0=下端, 0.5=中央, 1=上端)
                const imageCenterYInViewport = rect.top + rect.height / 2;
                const scrollProgress =
                  (viewportHeight - imageCenterYInViewport) / viewportHeight;

                // --- 奥行き方向の移動 (translateZ) ---
                // 中央に近づくほど手前に来る動き
                const parallaxZ = Math.sin(scrollProgress * Math.PI) * 0; // 最大100px手前に (調整可能)

                // --- 縦方向のパララックス移動 (translateY) ---
                // スクロール進行度に応じて上下に動かす
                // 0.5 (中央) で0px、端で最大値となるように調整
                // 例: -50px から +50px の範囲で動かす
                let parallaxEffectY = (scrollProgress - 0.5) * 50; // 係数100で、-50pxから50pxの範囲

                // --- 左右対称の視点移動 (translateX) ---
                // スクロール進行度に応じて左右に動かす
                // 中央に近づくほど動きが最大になり、端では0に近づくような動き
                let parallaxEffectX =
                  (0.5 - Math.abs(scrollProgress - 0.5)) * 0; // 最大80pxの横移動 (調整可能)

                if (image.classList.contains("new-section-image-top")) {
                  // 左側の画像は左へ動く（負の値）
                  parallaxEffectX *= -1; // 反転させる
                  // 左側の画像は少し上にずらす（動的なY軸調整）
                  parallaxEffectY -= (scrollProgress - 0.5) * 30; // 調整可能
                } else if (
                  image.classList.contains("new-section-image-bottom")
                ) {
                  // 右側の画像は右へ動く（正の値）
                  // 右側の画像は少し下にずらす（動的なY軸調整）
                  parallaxEffectY += (scrollProgress - 0.5) * 30; // 調整可能
                }

                // --- transform プロパティを適用 ---
                let currentTransform = `translateZ(${parallaxZ}px) translateX(${parallaxEffectX}px) translateY(${parallaxEffectY}px)`;

                // new-section-image-bottom には元々 translateY(15%) があるため、それを結合
                if (image.classList.contains("new-section-image-bottom")) {
                  // CSSのtransformを先に適用し、その後にJavaScriptの動的なtransformを適用する
                  // これにより、CSSで設定した初期位置を基準に動きが加わる
                  image.style.transform = `translateY(15%) ${currentTransform}`;
                } else {
                  image.style.transform = currentTransform;
                }
              } else {
                // ビューポート外に出たら transform をリセット
                // これにより、画像がビューポート外にある時は初期位置に戻る
                if (image.classList.contains("new-section-image-bottom")) {
                  image.style.transform = `translateY(15%) translateZ(0px) translateX(0px) translateY(0px)`;
                } else {
                  image.style.transform = `translateZ(0px) translateX(0px) translateY(0px)`;
                }
              }
            });
          });
        }
      });
     
      // script.js

      // ====================================
      // 画像のスクロール連動効果 (パララックス) - new-section の画像 (既存のコード)
      // ====================================
     
      document.addEventListener("DOMContentLoaded", () => {
  const newSectionImages = document.querySelectorAll(".new-section-common-image");

  if (newSectionImages.length > 0) {
    window.addEventListener("scroll", () => {
      const viewportHeight = window.innerHeight;

      newSectionImages.forEach((image) => {
        const rect = image.getBoundingClientRect();
        const isInViewport = rect.top < viewportHeight && rect.bottom > 0;

        if (isInViewport) {
          // 画像中心の位置と進行度
          const imageCenterYInViewport = rect.top + rect.height / 2;
          const scrollProgress = (viewportHeight - imageCenterYInViewport) / viewportHeight;

          const speed = parseFloat(image.dataset.parallaxSpeed) || 0.3;
          const parallaxEffectY = (scrollProgress - 0.5) * speed * 350;

          // 初期位置を崩さないようにY方向だけ変化させる
          image.style.transform = `translateY(${parallaxEffectY}px)`;
        } else {
          image.style.transform = `translateY(0px)`;
        }
      });
    });
  }
});


    

        document.addEventListener("DOMContentLoaded", () => {
          // ====================================
          // office-section の画像 (IMG_9955.png) のパララックス効果
          // 「閉じる」から「開く」効果と「真ん中で最大化」の調整
          // ====================================
          const officeImage = document.querySelector(".office-main-image");

          if (officeImage) {
            const sectionElement = officeImage.closest(".office-section");
            if (!sectionElement) return;

            window.addEventListener("scroll", () => {
              const sectionRect = sectionElement.getBoundingClientRect();
              const viewportHeight = window.innerHeight;

              const isSectionInView =
                sectionRect.top < viewportHeight && sectionRect.bottom > 0;

              if (isSectionInView) {
                const scrollProgress = Math.max(
                  0,
                  Math.min(
                    1,
                    (viewportHeight - sectionRect.top) /
                      (viewportHeight + sectionRect.height)
                  )
                );

                // --- clip-path (閉じる -> 開く) ロジック ---
                let insetAmount = 0;
                const animationMaxInset = 70; // 最大でどれくらい閉じるか (50% = 半分閉じる)
                const clipSpeedFactor = 0.1; // クリップのスピード調整 (0.1 (遅い) から 1.0 (速い) )

                // scrollProgressが0に近いほどinsetAmountが最大になり（閉じる）、
                // scrollProgressが1に近づくほどinsetAmountが0になる（開く）ようにする
                insetAmount = animationMaxInset * (1 - scrollProgress);
                insetAmount *= clipSpeedFactor;
                insetAmount = Math.max(
                  0,
                  Math.min(animationMaxInset, insetAmount)
                );
                const maxBorderRadius = 30; // 最大の角丸のピクセル値（この値を調整して丸みを調整）
                let currentBorderRadius = 20;
                officeImage.style.clipPath = `inset(${insetAmount}% 0% ${insetAmount}% 0% round ${currentBorderRadius}px)`;

                // --- scale (真ん中で最大化) ロジック ---
                // scrollProgressが0.5 (真ん中) で最大になるようにする
                // 0.5からの距離が近いほどscaleを大きくする
                const maxScaleIncrease = 0.1; // 最大でどれくらい拡大するか (例: 0.2 = 120%)
                let scaleValue =
                  1 +
                  maxScaleIncrease * (1 - Math.abs(scrollProgress - 0.5) * 2);
                // scaleValueは1.0 (最小) から 1.0 + maxScaleIncrease (最大) の範囲で変化します
                // 例: maxScaleIncreaseが0.2の場合、1.0から1.2の間で変化

                // --- transform の適用 ---
                // translateY は前の実装を維持
                const translateYAmount = (0.5 - scrollProgress) * 100;

                // translate(-50%, -50%) と translateYAmount、そして scaleValue を組み合わせる
                officeImage.style.transform = `translate(-50%, calc(-50% + ${translateYAmount}px)) scale(${scaleValue})`;
              } else {
                // セクションがビューポート外に出た場合、画像を初期位置に戻す
                officeImage.style.clipPath = `inset(${animationMaxInset}% 1% ${animationMaxInset}% %)`; // 完全に閉じた状態に戻す
                officeImage.style.transform = `translate(-50%, -50%) scale(1)`; // scaleも初期値の1に戻す
                戻す;
              }
            });
          }
        });
      
      
document.addEventListener("DOMContentLoaded", () => {
  const newSectionImages = document.querySelectorAll(".contact-parallax-img-1, .contact-parallax-img-2");

  if (newSectionImages.length > 0) {
    window.addEventListener("scroll", () => {
      const viewportHeight = window.innerHeight;

      newSectionImages.forEach((image) => {
        const rect = image.getBoundingClientRect();
        const isInViewport = rect.top < viewportHeight && rect.bottom > 0;

        if (isInViewport) {
          // 画像中心の位置と進行度
          const imageCenterYInViewport = rect.top + rect.height / 2;
          const scrollProgress = (viewportHeight - imageCenterYInViewport) / viewportHeight;

          const speed = parseFloat(image.dataset.parallaxSpeed) || 0.3;
          const parallaxEffectY = (scrollProgress - 0.5) * speed * 500;

          // 初期位置を崩さないようにY方向だけ変化させる
          image.style.transform = `translateY(${parallaxEffectY}px)`;
        } else {
          image.style.transform = `translateY(0px)`;
        }
      });
    });
  }
});

document.addEventListener("DOMContentLoaded", () => {
    // 既存のローディング関連の要素
    const loadingOverlay = document.getElementById("loading-overlay");
    const visitedKey = "hasVisitedWebsite";

    // 新しく追加するカスタムカーソル関連の要素と設定
    const cursor = document.createElement("div");
    cursor.classList.add("circle-cursor");
    cursor.textContent = "CONTACT"; // ← ここが表示されるテキスト
    document.body.appendChild(cursor); // bodyにカーソルを追加

    const targetSection = document.querySelector(".contact-section");

    // 【ここから新しい追加/修正部分】
    // ローディング表示中はカーソルを非表示にする
    cursor.style.display = "none"; // 初期状態ではカーソルを非表示にする

    const hideCustomCursor = () => {
        cursor.style.display = "none";
    };

    const showCustomCursor = () => {
        // ローディングが完全に非表示になった後にのみ表示
        if (loadingOverlay.classList.contains("hidden")) {
            cursor.style.display = "flex"; // flex にすることで中央寄せなどが効く
        }
    };

    // 既存のカスタムカーソルのイベントリスナーを調整
    if (targetSection) { // targetSectionが存在するか確認
        targetSection.addEventListener("mouseenter", showCustomCursor);
        targetSection.addEventListener("mouseleave", hideCustomCursor);

        targetSection.addEventListener("mousemove", (e) => {
            // ローディングが非表示の場合のみカーソル位置を更新
            if (loadingOverlay.classList.contains("hidden")) {
                cursor.style.left = e.clientX + "px";
                cursor.style.top = e.clientY + "px";
            }
        });

        targetSection.addEventListener("click", () => {
            // ローディングが非表示の場合のみリンクに飛ばす
            if (loadingOverlay.classList.contains("hidden")) {
                window.location.href = "https://example.com/contact"; // ← 飛ばすリンク
            }
        });
    }

    // ローディング表示/非表示のロジックにカーソル制御を追加
    const hideLoadingAndShowCursor = () => {
        loadingOverlay.classList.add("hidden");
        console.log("ローディング非表示。");
        localStorage.setItem(visitedKey, "true");

        // ローディングが完全に消えた後にカーソルを表示可能にする
        // ただし、すぐに表示せず、mouseenterで表示されるようにする
        // または、特定の条件で常に表示したい場合はここで `showCustomCursor()` を呼び出す
    };

    // 初回訪問時のローディング表示ロジック
    const hasVisited = localStorage.getItem(visitedKey);
    if (!hasVisited) {
        console.log("初回訪問です。ローディングを表示します。");
        // ローディングが表示されている間はカーソルを非表示
        hideCustomCursor();

        const MIN_LOADING_TIME = 10000;
        let startTime = Date.now();

        window.addEventListener("load", () => {
            const endTime = Date.now();
            const elapsedTime = endTime - startTime;
            if (elapsedTime < MIN_LOADING_TIME) {
                setTimeout(hideLoadingAndShowCursor, MIN_LOADING_TIME - elapsedTime);
            } else {
                hideLoadingAndShowCursor();
            }
        });

    } else {
        // 2回目以降の訪問の場合、ローディングを即座に隠す
        loadingOverlay.classList.add("hidden");
        console.log("2回目以降の訪問です。ローディングは表示しません。");
        // ページロード後すぐにカスタムカーソルを有効にする
        // (targetSection上にマウスがある場合に表示される)
    }
});

document.addEventListener("DOMContentLoaded", () => {
    // === ローディングオーバーレイのスクリプト (既存のもの) ===
    const loadingOverlay = document.getElementById("loading-overlay");
    const visitedKey = "hasVisitedWebsite";

      // ★追加: テキスト全体のフェードインアニメーションを開始する関数
      const startTextFadeInAnimation = () => {
        const verticalTextElement = document.querySelector(".vertical-text");
        if (verticalTextElement) {
            // ローディングが完全に消えてから少し時間をおいてアニメーションを開始
            // (ローディングの transition が終わる時間などを考慮)
            setTimeout(() => {
                verticalTextElement.classList.add("fade-in-active");
                console.log("テキスト全体のフェードインを開始しました。");
            }, 500); // 500ミリ秒（0.5秒）の遅延。調整してください。
        }
    };

    if (!loadingOverlay) {
        console.error("Loading overlay element not found!");
        startTextFadeInAnimation(); // オーバーレイがなければすぐにテキストアニメーション開始
        return;
    }

    const hasVisited = localStorage.getItem(visitedKey);

    if (!hasVisited) {
        console.log("初回訪問です。ローディングを表示します。");

        const MIN_LOADING_TIME = 10000; // 最低10秒表示
        let startTime = Date.now();

        window.addEventListener("load", () => {
            console.log("window.onload が発火しました。");
            const endTime = Date.now();
            const elapsedTime = endTime - startTime;
            console.log(`elapsedTime (読み込み時間): ${elapsedTime}ms`);

            const hideLoading = () => {
                loadingOverlay.classList.add("hidden");
                console.log("ローディング非表示。");
                localStorage.setItem(visitedKey, "true");
                
                // ★重要: ローディング完了後にテキスト全体フェードインアニメーションを開始
                startTextFadeInAnimation(); 
            };

            if (elapsedTime < MIN_LOADING_TIME) {
                const remainingTime = MIN_LOADING_TIME - elapsedTime;
                console.log(`読み込みが早いため、残り ${remainingTime}ms 待機します。`);
                setTimeout(hideLoading, remainingTime);
            } else {
                console.log("読み込み時間が設定時間以上のため、すぐに非表示にします。");
                hideLoading();
            }
        });

    } else {
        // 2回目以降の訪問です。ローディングは表示しません。
        loadingOverlay.classList.add("hidden");
        console.log("2回目以降の訪問です。ローディングは表示しません。");
        
        // ★重要: 2回目以降の訪問時も、すぐにテキスト全体フェードインアニメーションを開始
        startTextFadeInAnimation();
    }
});

    

  


document.addEventListener("DOMContentLoaded", function () {
  // 監視対象のセクション
  const section = document.querySelector("#our-story-section");

  // セクション内の個別要素たち（.fade-in-child クラスをつけたもの）
  const children = section.querySelectorAll(".fade-in-child");

  // IntersectionObserver の設定
  const observer = new IntersectionObserver(
    function (entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          // 子要素を1つずつフェードイン（300msごとにずらす）
          children.forEach((el, index) => {
            setTimeout(() => {
              el.classList.add("visible");
            }, index * 800); // ← ここで遅延の間隔を調整
          });

          // 一度表示されたら監視終了（必要に応じて削除可）
          observer.unobserve(entry.target);
        }
      });
    },
    {
      threshold: 0.1, // 10%表示されたら発動
    }
  );

  // セクションを監視対象に設定
  if (section) {
    observer.observe(section);
  } else {
    console.warn("#our-story-section が見つかりませんでした。");
  }
});
document.addEventListener("DOMContentLoaded", function () {
  // 監視対象の全セクション（複数対応）
  const sections = [
    document.querySelector("#our-story-section"),
    document.querySelector("#ginger-sentence-section")
  ];

  const observer = new IntersectionObserver(
    function (entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const children = entry.target.querySelectorAll(".fade-in-child");
          children.forEach((el, index) => {
            setTimeout(() => {
              el.classList.add("visible");
            }, index * 800);
          });
          observer.unobserve(entry.target);
        }
      });
    },
    {
      threshold: 0.1,
    }
  );

  sections.forEach((section) => {
    if (section) {
      observer.observe(section);
    }
  });
});
document.addEventListener("DOMContentLoaded", function () {
  const section = document.getElementById("company-profile-section");

  const observer = new IntersectionObserver(
    function (entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const children = entry.target.querySelectorAll(".fade-in-child");
children.forEach((el, index) => {
  setTimeout(() => {
    el.classList.add("visible");
  }, index * 700);
});
          observer.unobserve(entry.target);
        }
      });
    },
    {
      threshold: 0.1,
    }
  );

  if (section) {
    observer.observe(section);
  }
});

document.addEventListener("DOMContentLoaded", function () {
  const section = document.querySelector(".contact-section");

  const observer = new IntersectionObserver(
    function (entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const children = entry.target.querySelectorAll(".fade-in-child");
          children.forEach((el, index) => {
            setTimeout(() => {
              el.classList.add("visible");
            }, index * 800); // 200ms ごとに順番に表示
          });
          observer.unobserve(entry.target);
        }
      });
    },
    {
      threshold: 0.1, // セクションが10%表示された時点でアニメーション開始
    }
  );

  if (section) {
    observer.observe(section);
  }
});

document.addEventListener('DOMContentLoaded', function() {
  const menuButton = document.querySelector('.menu-button');

  if (menuButton) {
    menuButton.addEventListener('click', function(event) {
      event.preventDefault(); // デフォルトのリンク動作（ページ遷移）を停止

      console.log('メニューボタンがクリックされました！');
      // 例: ここにメニューを開く/閉じるなどの処理を追加できます
      // 例: document.body.classList.toggle('menu-is-open');

      // クリック時に一時的に色を変えるなどの視覚フィードバック
      const bookIcon = this.querySelector('.book-icon');
      const menuText = this.querySelector('.menu-text');

      if (bookIcon && menuText) {
        bookIcon.style.color = '#888'; // クリック時の一時的な色変更
        menuText.style.color = '#888';
        setTimeout(() => {
          bookIcon.style.color = 'black'; // 元の色に戻す
          menuText.style.color = 'black';
        }, 300); // 0.3秒後に元に戻す
      }
    });
  }
});
document.addEventListener('DOMContentLoaded', function() {
    const gingerIconContainer = document.querySelector('.ginger-icon-container');
    // アニメーションはコンテナ（.ginger-icon-container）に適用します
    // その他の要素（SVGやラベル）はコンテナの中で相対的に配置されます

    if (gingerIconContainer) {
        let startFloatingTime; // アニメーション開始時間
        const floatAmplitude = 4; // 左右の揺れ幅 (px) - 値を大きくすると揺れ幅が広がる
        const floatSpeed = 0.0010; // 揺れの速度 (小さいほど遅い) - 値を小さくするとゆっくりになる

        function animateFloat(currentTime) {
            if (!startFloatingTime) {
                startFloatingTime = currentTime;
            }
            const elapsedTime = currentTime - startFloatingTime;

            // Math.sinを使って左右に揺れる動きを計算
            // サイン波が -1 から 1 の範囲で変化するため、floatAmplitudeを掛けて揺れ幅を調整
            const offsetX = floatAmplitude * Math.sin(elapsedTime * floatSpeed);
            
            // translate3dを使うとGPUアクセラレーションが効きやすく、より滑らかに動く傾向があります
            gingerIconContainer.style.transform = `translateX(${offsetX}px)`;

            // 次のフレームでアニメーションを継続
            requestAnimationFrame(animateFloat);
        }

        // アニメーションを開始
        requestAnimationFrame(animateFloat);

        // --- (オプション) クリック時のインタラクション ---
        // もしクリック時のアニメーションも残したい場合は、以下のコメントを外して使用してください
        /*
        gingerIconContainer.addEventListener('click', function() {
            console.log('ジンジャーアイコンがクリックされました！');
            // クリック時の色変更などの視覚フィードバック
            const gingerIconSvg = document.querySelector('.ginger-icon');
            const iconLabel = document.querySelector('.icon-label');
            if (gingerIconSvg) {
                gingerIconSvg.style.fill = '#a06e22'; 
                gingerIconSvg.style.stroke = '#a06e22';
                // ラベルの色も変更したい場合
                if (iconLabel) {
                    iconLabel.style.color = '#a06e22';
                }
                setTimeout(() => {
                    gingerIconSvg.style.fill = '#e8a130'; 
                    gingerIconSvg.style.stroke = '#e8a130';
                    // ラベルの色を元に戻す場合
                    if (iconLabel) {
                        iconLabel.style.color = '#e8a130';
                    }
                }, 300);
            }
            // 注意: クリック時のtransformと自動浮遊のtransformが競合しないように、
            // クリック時のアニメーションは色の変更にとどめるか、transformを一時的に無効にするロジックが必要です。
            // 今回のコードでは、自動アニメーションのtransformがクリック時のtransformを上書きするため、
            // クリック時のtransformアニメーションは一時的に表示されるだけになります。
        });
        */
    }
});
  </script>
  </body>
</html>
